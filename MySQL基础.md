# Mysql

---
## 1.索引
### 1.1 使用索引前
> mysql的基本存储结构是页(记录)
页与页之间是双向，页里面的记录是单向链表
### 1.2 使用索引后
> 使用了B+tree来将数据排序
(为啥不用二叉树或者红黑树呢？因为数据库数据存储在磁盘上的，查询速度的快慢是看io读取的次数多少来决定的。假设是用红黑树或者二叉树，虽然达到了查询速度快，但是一个节点只有两个子节点，导致在查询数据时需要访问多层的节点数据，访问多层也就是io读取次数变多了。而B+tree则在一层上尽可能的放上多个数据，避免多层的访问，保证io读取次数减少)
> 
+ Tree
    - B-Tree
    - B+Tree
+ hash
> 主要思路是通过哈希算法，将键值换成哈希值。但有几个问题：
1.无法遵守最左原则
2.无法范围查询
3.会有碰撞问题，效率低
4.无法利用索引完成排序

### 1.3最左匹配原则
> 如果一个表创建了abc三个索引，如果用 bc,b,c 是不会使用到索引的。
另外，遇到范围查询(> < like )是不会进一步匹配的。例如：
a = 1 and b > 1 and c = 1 此时只用用了 只会命中 a b。
对于 = in也是不需要考虑顺序问题，例如 a = 1 and c > 1 and b = 2,a b c三个都会命中的

### 1.4 聚集索引和非聚集索引，覆盖索引
> + 聚集索引：以主键创建的索引
+ 非聚集索引：以非主键创建的索引
+ 覆盖索引：假设根据非聚集索引查询时，会再根据主键再查多一次表，这种叫回表。为了避免这个情况，我们理应将查询的字段和索引字段对应上，这个就叫覆盖索引。


## 2.锁
### 2.1划分
> + 使用方式：乐观锁，悲观锁
+ 粒度： 表级锁(MyISAM,InnoDB) 行级锁(InnoDB) 页级锁(BDB)
 - 表锁：表读锁和表写锁
 - 行锁：共享锁(读锁，S锁)和排他锁(写锁，X锁)
 - 意向锁：为了允许行锁和表锁共存，实现多粒度锁机制，分别有:
 a) 意向共享锁(IS):事务打算给数据行加行共享锁时，必须先取得IS锁
 b) 意向排他锁(IX):事务打算给数据行加行排他锁时，必须先获取IX锁
  以上两种意向锁都是表锁。  
## 3. for update 
### 3.1一致性
> + 悲观锁：
set autocommit = 0;
begin;
select * from sys_user where id = '000000005ea7b903015ea7ce92ce0001' for UPDATE;
update sys_user set pwd = '123' where id = '000000005ea7b903015ea7ce92ce0001'
COMMIT;
+ 乐观锁：主要通过cas的方式

### 3.2表级锁 行级锁
> + 当for update的字段为索引或者主键的时候，只会锁住索引或者主键对应的行
 1.根据主键/索引字段查不出数据 则不产生锁
 2.根据主键、非主键不含索引（name）进行查询，没有查询到数据，不产生锁
+ 当for update的字段为普通字段的时候，Innodb会锁住整张表




